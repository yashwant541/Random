# =============================================================================
# DATAIKU TEXT FILE PROCESSING - REMOVE STANDALONE NUMBERS (TAB SAFE)
# =============================================================================

import dataiku
import re
import os
from decimal import Decimal, InvalidOperation
from typing import List, Tuple, Optional

# =============================================================================
# CONFIGURATION
# =============================================================================

INPUT_FOLDER_ID = "xFGhJtYE"
OUTPUT_FOLDER_ID = "output_folder_id"

START_NUMBER = 1
END_NUMBER = 30

INCLUDE_PERCENTAGES = True
INCLUDE_CURRENCY = True
INCLUDE_COMMAS = True
INCLUDE_SCIENTIFIC = True

REMOVE_EMPTY_LINES = False
LOG_PROCESSING = True

# =============================================================================
# DATAIKU HELPERS
# =============================================================================

def get_input_folder():
    return dataiku.Folder(INPUT_FOLDER_ID)

def get_output_folder():
    return dataiku.Folder(OUTPUT_FOLDER_ID)

# =============================================================================
# NUMBER PARSING
# =============================================================================

def parse_number_string(text: str) -> Optional[Decimal]:
    if not text:
        return None

    s = text.strip()

    if INCLUDE_PERCENTAGES and s.endswith('%'):
        try:
            return Decimal(s[:-1].replace(',', '')) / Decimal('100')
        except InvalidOperation:
            return None

    if INCLUDE_CURRENCY:
        for c in ['$', '‚Ç¨', '¬£', '¬•', '‚Çπ', '‚ÇΩ', '‚Ç©']:
            if s.startswith(c):
                s = s[len(c):].strip()
                break

    if s.startswith('(') and s.endswith(')'):
        s = '-' + s[1:-1]

    s = s.replace(',', '')

    try:
        return Decimal(s)
    except InvalidOperation:
        return None

def is_number_in_range(text: str, start: Decimal, end: Decimal) -> bool:
    val = parse_number_string(text)
    return val is not None and start <= val <= end

# =============================================================================
# REGEX (CRITICAL FIX)
# =============================================================================

def get_number_pattern() -> re.Pattern:
    number_core = r'''
        -?
        (?:\d{1,3}(?:,\d{3})+|\d+|\.\d+)
        (?:\.\d+)?
        (?:[eE][+-]?\d+)?
    '''

    if INCLUDE_CURRENCY:
        number_core = r'(?:[$‚Ç¨¬£¬•‚Çπ‚ÇΩ‚Ç©]\s*)?' + number_core

    if INCLUDE_PERCENTAGES:
        number_core += r'(?:\s*%)?'

    # Standalone = surrounded by whitespace (TAB SAFE)
    return re.compile(rf'(?<!\S){number_core}(?!\S)', re.VERBOSE)

# =============================================================================
# CORE LOGIC
# =============================================================================

def remove_numbers_from_text(text: str,
                             start: Decimal,
                             end: Decimal) -> Tuple[str, List[str]]:

    pattern = get_number_pattern()
    removed = []

    lines = text.splitlines(True)
    output = []

    for line in lines:
        matches = list(pattern.finditer(line))
        new_line = line

        for m in reversed(matches):
            token = m.group()

            if is_number_in_range(token, start, end):
                removed.append(token)
                new_line = new_line[:m.start()] + new_line[m.end():]

        # ---- TAB & SPACE CLEANUP (TXT SAFE) ----
        new_line = re.sub(r'\t{2,}', '\t', new_line)
        new_line = re.sub(r' {2,}', ' ', new_line)
        new_line = new_line.strip(' \t')

        if not (REMOVE_EMPTY_LINES and new_line.strip() == ''):
            output.append(new_line)

    return ''.join(output), removed

# =============================================================================
# FILE PROCESSING
# =============================================================================

def process_file(filename: str, start: Decimal, end: Decimal):
    input_folder = get_input_folder()
    output_folder = get_output_folder()

    with input_folder.get_download_stream(filename) as f:
        raw = f.read().decode('utf-8', errors='ignore')

    cleaned, removed = remove_numbers_from_text(raw, start, end)

    out_name = os.path.splitext(filename)[0] + "_cleaned.txt"

    with output_folder.get_writer(out_name) as w:
        w.write(cleaned.encode('utf-8'))

    print(f"‚úÖ {filename} ‚Üí {out_name} | removed {len(removed)} numbers")

# =============================================================================
# BATCH RUN
# =============================================================================

def run():
    input_folder = get_input_folder()
    files = [f for f in input_folder.list_paths_in_partition() if f.lower().endswith('.txt')]

    if not files:
        print("‚ùå No TXT files found")
        return

    start = Decimal(str(START_NUMBER))
    end = Decimal(str(END_NUMBER))

    for f in files:
        process_file(f, start, end)

    print("\nüéâ Processing complete")

# =============================================================================
# ENTRY POINT
# =============================================================================

if __name__ == "__main__":
    run()
