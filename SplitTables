import dataiku
import pandas as pd
import io
import time
from pathlib import Path

# =============================================================================
# CONFIGURATION
# =============================================================================
INPUT_FOLDER_ID = "xFGhJtYE"           # Your input folder ID
OUTPUT_FOLDER_ID = "output_folder_id"  # Your output folder ID
SHEET_TO_READ = "All_Tables"           # Sheet containing all tables
TABLE_NUMBER_COLUMN = "Table_Number"   # Column that identifies table numbers

# =============================================================================
# SIMPLE DATAIKU FUNCTIONS
# =============================================================================

def get_input_folder():
    return dataiku.Folder(INPUT_FOLDER_ID)

def get_output_folder():
    return dataiku.Folder(OUTPUT_FOLDER_ID)

def list_excel_files():
    folder = get_input_folder()
    return sorted([f for f in folder.list_paths_in_partition() 
                   if f.lower().endswith('.xlsx')])

# =============================================================================
# ULTRA-FAST PROCESSING FOR SMALL FILES
# =============================================================================

def super_fast_split(input_filename: str):
    """
    Ultra-fast processing for small files (< 1MB)
    """
    print(f"üöÄ Processing: {input_filename}")
    start_total = time.time()
    
    try:
        # ============================================
        # 1. QUICK DOWNLOAD (should be instant for 40KB)
        # ============================================
        download_start = time.time()
        folder = get_input_folder()
        
        with folder.get_download_stream(input_filename) as stream:
            excel_bytes = stream.read()
        
        download_time = time.time() - download_start
        print(f"   üì• Downloaded {len(excel_bytes):,} bytes in {download_time:.3f}s")
        
        # ============================================
        # 2. QUICK LOAD TO DATAFRAME
        # ============================================
        load_start = time.time()
        
        # Read directly from bytes
        excel_file = io.BytesIO(excel_bytes)
        
        # Try specified sheet, fall back to first sheet
        try:
            df = pd.read_excel(excel_file, sheet_name=SHEET_TO_READ, engine='openpyxl')
        except:
            excel_file.seek(0)
            df = pd.read_excel(excel_file, engine='openpyxl')
        
        load_time = time.time() - load_start
        print(f"   üìä Loaded {len(df)} rows, {len(df.columns)} cols in {load_time:.3f}s")
        
        # ============================================
        # 3. QUICK VALIDATION
        # ============================================
        if TABLE_NUMBER_COLUMN not in df.columns:
            # Try case-insensitive search
            matching_cols = [col for col in df.columns if TABLE_NUMBER_COLUMN.lower() in str(col).lower()]
            if matching_cols:
                actual_col = matching_cols[0]
                print(f"   ‚ö†Ô∏è  Using '{actual_col}' instead of '{TABLE_NUMBER_COLUMN}'")
                table_col = actual_col
            else:
                print(f"   ‚ùå No '{TABLE_NUMBER_COLUMN}' column found!")
                print(f"   Available columns: {list(df.columns)}")
                return None
        else:
            table_col = TABLE_NUMBER_COLUMN
        
        # ============================================
        # 4. SUPER FAST GROUPING
        # ============================================
        group_start = time.time()
        
        # Get unique table numbers
        table_numbers = df[table_col].dropna().unique()
        table_numbers = sorted([int(x) for x in table_numbers if pd.notna(x)])
        
        print(f"   üîÄ Found {len(table_numbers)} tables in {time.time() - group_start:.3f}s")
        
        # ============================================
        # 5. CREATE OUTPUT IN MEMORY
        # ============================================
        write_start = time.time()
        
        output_buffer = io.BytesIO()
        
        with pd.ExcelWriter(output_buffer, engine='openpyxl') as writer:
            # Keep original
            df.to_excel(writer, sheet_name='All_Tables', index=False)
            
            # Create individual sheets
            sheets_created = 0
            for table_num in table_numbers:
                # Filter for this table
                table_data = df[df[table_col] == table_num].copy()
                
                # Remove the table number column (it's redundant in individual sheets)
                if table_col in table_data.columns:
                    table_data = table_data.drop(columns=[table_col])
                
                # Add row numbers
                table_data.insert(0, 'Row', range(1, len(table_data) + 1))
                
                # Create sheet name
                sheet_name = f"Table {table_num}"
                if len(sheet_name) > 31:
                    sheet_name = sheet_name[:31]
                
                # Write to sheet
                table_data.to_excel(writer, sheet_name=sheet_name, index=False)
                sheets_created += 1
            
            # Simple summary
            summary_df = pd.DataFrame({
                'Table_Number': table_numbers,
                'Row_Count': [len(df[df[table_col] == tn]) for tn in table_numbers]
            })
            summary_df.to_excel(writer, sheet_name='Summary', index=False)
        
        write_time = time.time() - write_start
        print(f"   üíæ Created {sheets_created + 2} sheets in {write_time:.3f}s")
        
        # ============================================
        # 6. QUICK UPLOAD
        # ============================================
        upload_start = time.time()
        
        output_bytes = output_buffer.getvalue()
        output_folder = get_output_folder()
        
        output_filename = f"{Path(input_filename).stem}_split.xlsx"
        
        with output_folder.get_writer(output_filename) as writer:
            writer.write(output_bytes)
        
        upload_time = time.time() - upload_start
        
        # ============================================
        # 7. FINAL RESULTS
        # ============================================
        total_time = time.time() - start_total
        
        print(f"\n‚úÖ COMPLETED IN {total_time:.3f} SECONDS!")
        print(f"   Download: {download_time:.3f}s")
        print(f"   Load: {load_time:.3f}s")
        print(f"   Process: {write_time:.3f}s")
        print(f"   Upload: {upload_time:.3f}s")
        print(f"\nüìÅ Output: {output_filename}")
        print(f"üìä {sheets_created} tables split into individual sheets")
        print(f"üíæ Output size: {len(output_bytes):,} bytes")
        
        return output_filename
        
    except Exception as e:
        print(f"‚ùå ERROR: {str(e)[:100]}...")
        return None

# =============================================================================
# BATCH PROCESS ALL FILES
# =============================================================================

def batch_process_all():
    """
    Process all files in the folder
    """
    print(f"\n{'='*50}")
    print("DATAIKU TABLE SPLITTER - BATCH MODE")
    print(f"{'='*50}")
    
    files = list_excel_files()
    
    if not files:
        print("‚ùå No Excel files found in the folder!")
        return
    
    print(f"Found {len(files)} file(s):")
    for i, f in enumerate(files, 1):
        print(f"  {i}. {f}")
    
    print(f"\nüöÄ Starting batch processing...")
    
    results = []
    total_start = time.time()
    
    for filename in files:
        print(f"\n{'='*50}")
        result = super_fast_split(filename)
        
        if result:
            results.append({
                'input': filename,
                'output': result,
                'status': 'success'
            })
        else:
            results.append({
                'input': filename,
                'status': 'failed'
            })
    
    total_time = time.time() - total_start
    
    print(f"\n{'='*50}")
    print("BATCH PROCESSING COMPLETE!")
    print(f"{'='*50}")
    
    successful = [r for r in results if r['status'] == 'success']
    failed = [r for r in results if r['status'] == 'failed']
    
    print(f"Total files: {len(results)}")
    print(f"Successful: {len(successful)}")
    print(f"Failed: {len(failed)}")
    print(f"Total time: {total_time:.2f}s")
    print(f"Average per file: {total_time/len(results):.2f}s")
    
    if successful:
        print(f"\n‚úÖ Output files created:")
        for result in successful:
            print(f"  ‚Ä¢ {result['output']}")

# =============================================================================
# SIMPLE MENU
# =============================================================================

def main():
    """
    Simple menu for processing
    """
    print(f"\n{'='*50}")
    print("DATAIKU TABLE SPLITTER")
    print(f"{'='*50}")
    
    files = list_excel_files()
    
    if not files:
        print("Please upload Excel files to the input folder.")
        return
    
    print(f"Files available ({len(files)}):")
    for i, f in enumerate(files, 1):
        print(f"  {i}. {f}")
    
    print(f"\nOptions:")
    print("  1. Process ALL files")
    print("  2. Process specific file")
    print("  3. Test with first file")
    
    choice = input("\nSelect option (1-3): ").strip()
    
    if choice == '1':
        batch_process_all()
    elif choice == '2':
        file_num = input(f"Enter file number (1-{len(files)}): ").strip()
        try:
            idx = int(file_num) - 1
            if 0 <= idx < len(files):
                super_fast_split(files[idx])
            else:
                print("Invalid file number!")
        except:
            print("Please enter a valid number!")
    elif choice == '3':
        super_fast_split(files[0])
    else:
        print("Invalid choice!")

# =============================================================================
# DIRECT EXECUTION
# =============================================================================

if __name__ == "__main__":
    # Just run it directly - no fancy stuff
    main()
